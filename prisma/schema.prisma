generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum Role {
  ADMIN
  CUSTOMER
}

enum CustomerType {
  PF
  PJ
}

enum AccountStatus {
  not_requested
  requested
  approved
  rejected
  in_review
}

enum PixKeyType {
  CPF
  CNPJ
  EMAIL
  PHONE
  RANDOM
}

enum PixKeyStatus {
  PENDING
  ACTIVE
  BLOCKED
  DELETED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  CONFIRMED
  FAILED
  CANCELED
}

enum DepositStatus {
  PENDING
  CONFIRMED
  FAILED
  REFUNDED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

enum CardTransactionStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  CANCELED
  REFUNDED
  FAILED
}

enum CardTransactionType {
  DEBIT
  CREDIT
}

enum ChargebackStatus {
  OPENED
  UNDER_ANALYSIS
  WON
  LOST
  CANCELED
}

enum ChargebackReason {
  FRAUD
  PRODUCT_NOT_RECEIVED
  PRODUCT_DEFECTIVE
  DUPLICATE_CHARGE
  CANCELED_RECURRING
  OTHER
}

enum TransactionType {
  DEPOSIT
  WITHDRAW
  TRANSFER_IN
  TRANSFER_OUT
  PIX_IN
  PIX_OUT
  FEE
  REVERSAL
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REVERSED
  CANCELED
}

// ==================== AUTH ====================

model User {
  id                String    @id @default(cuid())
  email             String    @unique
  passwordHash      String    @map("password")
  name              String?
  role              Role      @default(ADMIN)
  isActive          Boolean   @default(true)
  passwordChangedAt DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  customers           Customer[]
  passwordResetTokens PasswordResetToken[]
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
}

// ==================== CUSTOMER ====================

model Customer {
  id            String        @id @default(uuid())
  type          CustomerType
  accountStatus AccountStatus @default(not_requested)

  // Auth
  userId   String? @unique
  authUser User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Integração externa
  externalClientId String? @unique
  externalAccredId String? @unique

  // Base
  identifier String
  productId  Int
  email      String
  phone      String?

  // PF
  name       String?
  socialName String?
  cpf        String?   @unique
  birthday   DateTime?
  genderId   Int?

  // PJ
  legalName String?
  tradeName String?
  cnpj      String? @unique

  // Relações
  address          Address?
  pixLimits        PixLimits?
  account          Account?
  ownerships       Ownership[]
  pixKeys          PixKey[]
  cardTransactions CardTransaction[]
  chargebacks      Chargeback[]
  refunds          Refund[]
  payments         Payment[]
  deposits         Deposit[]
  wallets          Wallet[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type, accountStatus])
  @@index([cpf])
  @@index([cnpj])
  @@index([email])
}

model Address {
  id           String  @id @default(uuid())
  customerId   String  @unique
  zipCode      String
  street       String
  number       String?
  complement   String?
  city         String?
  state        String?
  neighborhood String
  cityIbgeCode Int

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([cityIbgeCode])
}

model PixLimits {
  id             String  @id @default(uuid())
  customerId     String  @unique
  singleTransfer Decimal @db.Decimal(15, 2)
  daytime        Decimal @db.Decimal(15, 2)
  nighttime      Decimal @db.Decimal(15, 2)
  monthly        Decimal @db.Decimal(15, 2)
  serviceId      Int

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model Ownership {
  id              String   @id @default(uuid())
  customerId      String
  name            String
  cpf             String
  birthday        DateTime
  isAdministrator Boolean

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
}

model PixKey {
  id         String       @id @default(uuid())
  customerId String
  keyType    PixKeyType
  keyValue   String
  status     PixKeyStatus @default(PENDING)

  externalKeyId String? @unique
  accountType   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([customerId, keyValue])
  @@index([customerId, status])
  @@index([keyValue])
}

// ==================== TRANSACTIONS ====================

model Payment {
  id           String  @id @default(uuid())
  endToEnd     String  @unique
  identifier   String?
  paymentValue Int

  receiverName      String?
  receiverTaxNumber String?
  receiverPixKey    String?
  receiverBankCode  String?

  payerName      String?
  payerTaxNumber String?

  paymentDate  DateTime
  status       PaymentStatus @default(PENDING)
  errorMessage String?       @db.Text

  bankPayload Json
  externalId  String? @unique

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([status, createdAt])
}

model Deposit {
  id           String   @id @default(uuid())
  endToEnd     String   @unique
  receiptValue Int
  receiptDate  DateTime

  payerName      String?
  payerTaxNumber String?
  payerMessage   String? @db.Text

  receiverPixKey String?

  status       DepositStatus @default(PENDING)
  errorMessage String?       @db.Text

  bankPayload Json
  externalId  String? @unique

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([customerId])
  @@index([status, createdAt])
  @@index([endToEnd])
}

model Refund {
  id          String    @id @default(uuid())
  endToEnd    String    @unique
  status      String?
  statusId    Int?
  valueCents  Int?
  refundDate  DateTime?
  bankPayload Json

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([customerId])
}

// ==================== WALLET & PAYOUT ====================

model Wallet {
  id         String  @id @default(cuid())
  customerId String
  currency   String  @default("BRL")
  balance    Decimal @db.Decimal(18, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  payouts  Payout[]

  @@unique([customerId, currency])
  @@index([customerId])
}

model Payout {
  id         String       @id @default(cuid())
  walletId   String
  amount     Decimal      @db.Decimal(18, 2)
  status     PayoutStatus @default(PENDING)
  requestId  String       @unique
  endToEndId String?      @unique

  bankRequest  Json?
  bankResponse Json?
  error        String? @db.Text

  beneficiaryName      String
  beneficiaryTaxNumber String
  pixKey               String
  pixKeyType           String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  wallet    Wallet       @relation(fields: [walletId], references: [id], onDelete: Cascade)
  debitTx   Transaction? @relation(fields: [debitTxId], references: [id], onDelete: SetNull)
  debitTxId String?      @unique

  @@index([walletId, createdAt])
  @@index([status])
}

// ==================== ACCOUNT & TRANSACTIONS ====================

model Account {
  id         String  @id @default(uuid())
  customerId String  @unique
  balance    Decimal @default(0) @db.Decimal(15, 2)

  pixKey     String? @unique
  pixKeyType String? @default("RANDOM")

  dailyLimit   Decimal @default(5000) @db.Decimal(15, 2)
  monthlyLimit Decimal @default(20000) @db.Decimal(15, 2)

  status        String  @default("active")
  blockedAmount Decimal @default(0) @db.Decimal(15, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer     Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@index([customerId])
  @@map("accounts")
}

model Transaction {
  id        String @id @default(uuid())
  accountId String

  type   TransactionType
  status TransactionStatus

  amount        Decimal @db.Decimal(15, 2)
  balanceBefore Decimal @db.Decimal(15, 2)
  balanceAfter  Decimal @db.Decimal(15, 2)

  description String?
  metadata    Json?

  externalId   String? @unique
  externalData Json?

  relatedTxId String? @unique

  createdAt   DateTime  @default(now())
  processedAt DateTime?
  completedAt DateTime?

  account       Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  relatedTx     Transaction? @relation("RelatedTransactions", fields: [relatedTxId], references: [id], onDelete: SetNull)
  counterpartTx Transaction? @relation("RelatedTransactions")
  payouts       Payout[]

  @@index([accountId, createdAt])
  @@index([type, status])
  @@index([externalId])
  @@map("transactions")
}

// ==================== CARD TRANSACTIONS ====================

model CardTransaction {
  id         String @id @default(uuid())
  customerId String

  amount   Int
  currency String                @default("BRL")
  type     CardTransactionType
  status   CardTransactionStatus @default(PENDING)

  cardLast4 String
  cardBrand String

  authorizationCode String?
  nsu               String?
  tid               String?

  merchantName     String?
  merchantCategory String?
  description      String?

  hasChargeback Boolean @default(false)
  chargebackId  String? @unique

  externalTxId String? @unique
  bankPayload  Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer   Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  chargeback Chargeback?

  @@index([customerId, status, createdAt])
  @@index([status])
}

model Chargeback {
  id                String @id @default(uuid())
  cardTransactionId String @unique
  customerId        String

  amount Int
  reason ChargebackReason
  status ChargebackStatus @default(OPENED)

  customerEvidence Json?
  bankEvidence     Json?

  openedAt   DateTime  @default(now())
  deadlineAt DateTime?
  resolvedAt DateTime?

  favoredParty String?
  notes        String? @db.Text

  externalCaseId String? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cardTransaction CardTransaction @relation(fields: [cardTransactionId], references: [id], onDelete: Cascade)
  customer        Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId, status])
  @@index([status, openedAt])
}

// ==================== WEBHOOK LOGS ====================

model WebhookLog {
  id        String  @id @default(uuid())
  source    String
  type      String
  payload   Json
  processed Boolean @default(false)
  error     String? @db.Text

  endToEnd String?
  txid     String?

  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@index([source, type, createdAt])
  @@index([endToEnd])
  @@index([processed])
  @@map("webhook_logs")
}
